# 행렬 *matrix*
값들을 행과 열로 나열하는 것을 행렬이라고 한다. 행렬은 연립방정식(Simultaneous Equation)을 풀기 위해 개발된 개념으로 수, 문자, 함수 등을 네모꼴 괄호 안에 배열하여 놓은 것을 말한다. 행렬의 각 성분은 실수여야 하고, 이를 스칼라(Scalar)라고 한다.

| a<sub>11</sub> | a<sub>12</sub> | a<sub>13</sub>| ... | a<sub>1n</sub>|
|--|--|--|--|--|
| a<sub>21</sub> | a<sub>22</sub> | a<sub>23</sub>| ... | a<sub>2n</sub>|

각각이 n쌍으로 된 m개의 수평 성분 (a<sub>i1</sub>, a<sub>i2</sub> ... a<sub>in</sub>)을 행(row)이라 하고, 각각이 m 쌍으로 된 n개의 수직 성분 (a<sub>1j</sub>, a<sub>2j</sub> ... a<sub>mj</sub>)을 열(column)이라 한다.

이러한 행렬을 m X n 행렬이라 하고, m by n 행렬이라고 읽는다.

## 행렬의 덧셈
행렬 A와 B가 같은 크기의 행과 열을 갖는다고 하면, 행렬 A와 B의 합을 A+B로 표시하고 A+B = (a<sub>ij</sub>) + (b<sub>ij</sub>) = (a<sub>ij</sub> + b<sub>ij</sub>)이다. 즉, 대응하는 성분끼리의 합을 구하면 된다.

각 성분이 0인 행렬을 영행렬(zero matrix)이라 한다.

## 행렬의 곱
A는 m X p 행렬이고 B는 p X n 행렬이라 하자. 그러면 A와 B의 행렬곱 AB는 m X n 행렬이고 C = c<sub>ij</sub>가 된다.

c<sub>ij</sub> = a<sub>i1</sub>b<sub>1j</sub> + a<sub>i2</sub>b<sub>2j</sub> + ... + a<sub>ip</sub>b<sub>pj</sub>

즉 행렬의 곱을 구하기 위해서는 A의 열의 개수와 B의 행의 개수가 같아야 한다.

### 행렬곱과 프로그래밍
```python
def dot(A,B,C):
	for i in range(m):
		for j in range(s):
			c[i][j] = 0
			for k in range(n):
				c[i][j] = c[i][j] + a[i][k] * b[k][j]
```

위 알고리즘은 흔히 행렬곱을 계산하기 위해 쓰이는 코드이다.

이 알고리즘을 프로그래밍 언어를 달리하여 적용해보면 실행 시간에 차이가 나는 것을 볼 수 있는데, 이는 일반적으로 프로그래밍 언어들이 2차원 이상의 행렬을 메모리에 저장할 때, 1차원으로 저장하기 위해 행 우선(row major)이나 열 우선(column major)으로 저장하는 방법에 따라 각각의 원소들을 액세스하는 시간이 차이가 나기 때문이다. 공간 지역성과 시간 지역성에 따라 차이가 난다.

행 우선 방법의 대표적 언어는 C언어이고, 열 우선 방법의 대표적 언어는 Fortran 언어이다.

## 특수 행렬
행과 열의 수가 n으로 같은 행렬을 n차 정방 행렬(square matrix)이라고 하며, 이때 행 또는 열의 개수를 정방 행렬의 차수라고 한다.

n차 정방 행렬에서 대각선상에 위치한 원소, 즉 a<sub>ii</sub>(i=1,2,3, ..., n)를 주대각(main diagonal) 원소라고 하며, 주대각 원소를 제외한 나머지 원소(off-diagonal)가 모두 0인 행렬을 대각 행렬(diagonal matrix)이라고 한다.

정방 행렬에서는 대각 행렬을 포함해서 여러 가지 특수한 성질을 갖는 행렬이 있다.

### 대각 행렬 *Diagonal Matrix*

```
[[2, 0],
 [0, 3]]
```
 
### 단위 행렬 *Identity Matrix*
단위 행렬(또는 항등 행렬)은 주대각 원소들은 모두 1이고, 주대각 원소를 제외한 원소들은 0인 정방 행렬이다.

```
[[1, 0, 0].
 [0, 1, 0],
 [0, 0, 1]]
```

### 스칼라 행렬 *Scalar Matrix*
스칼라 행렬은 주대각 원소들이 모두 같은 값을 갖는 대각 행렬이다.
```
[[4, 0, 0],
 [0, 4, 0].
 [0, 0, 4]]
 ```

### 전치 행렬 *Transpose Matrix*
전치 행렬은 임의의 m X n 행렬 A에 대해 행과 열을 바꾸어서 얻어진 n X m을 말한다. 이 행렬을 A의 전치행렬 A<sup>T</sup>로 나타낸다.

### 대칭 행렬 *Symmetric Matrix*
자신과 자신의 전치 행렬이 같은 행렬을 대칭 행렬이라고 한다.

### 삼각 행렬 *Triangular Matrix*
삼각 행렬은 상삼각 행렬과 하삼각 행렬로 나뉘는데, 각각 주대각 원소의 아래, 혹은 위쪽의 원소들이 모두 0인 행렬을 의미한다.

```
[[3, 5],    #상삼각 행렬
 [0, 2]]    
```

```
[[3, 0],    #하삼각 행렬
 [5, 2]]
```

### 그 외의 행렬들
이 외에도 띠 행렬*Band Matrix*, 특이 행렬*Singular Matrix*, 정칙 행렬*Non-Singular Matrix* 등이 있다.

## 역행렬 *Inverse Matrix*
정방 행렬 A에대하여 `AB = BA = I`를 만족하는 정방 행렬 B가 존재할 때, A는 가역*Invertible*이라 하고, B를 A의 역행렬이라 하며 A<sup>-1</sup>으로 표시한다. 또한, 가역이라함은 역행렬이 존재한다는 뜻이다.

### 역행렬 구하기
역행렬을 구하는 방법은 매우 다양한데, 일반적인 방법은 연립방정식을 이용해 푸는 것이다.

연립방정식을 푸는 방법은 가우스 소거법과 가우스-조던 소거법과 같이 직접적인 해를 구하는 방법과, 야코비*Jacobi* 방법과 가우스-자이델*Gauss-Seidel* 방법과 같이 반복적으로 해를 구하는 방법이 있다.

#### 가우스 조단 방법 *Gauss-Jordan Method*
행렬 `A=[[3,5],[2,3]]`의 역행렬을 구해보자.

먼저 증가 행렬*Argumented Matrix*을 만든다.
```
[[3, 5], :  [[1, 0],
 [2, 3]] :   [0, 1]]
```

1행 1열을 1로 만들기 위해 1행을 3으로 나누어서 1행을 다시 만든다.

```
[[1, 5/3], :  [[1/3, 0],
 [2, 3]] :   [0, 1]]
```

2행 1열을 0으로 만들기 위해 1행에 -2를 곱하고 2행에 더해서 2행을 다시 만든다.

```
[[1, 5/3], :  [[1/3, 0],
 [0, -1/3]] :   [-2/3, 1]]
```

2행 2열을 1로 만들기 위해 2열에 -3을 곱한다.

```
[[1, 5/3], :  [[1/3, 0],
 [0, 1]] :   [2, -3]]
```

1행 2열을 0으로 만들기 위해 2행에 -5/3을 곱하고 1행에 더한다.

```
[[1, 0], :  [[-3, 5],
 [0, 1]] :   [2, -3]]
```

따라서 행렬 A의 역행렬 A<sup>-1</sup>은 `[[-3, 5], [2, -3]]`이다.

#### 직교 행렬 *Orthogonal Matrix*
전치행렬이 직교행렬과 같은 행렬을 직교 행렬이라고 한다.

A<sup>T</sup> = A<sup>-1</sup>인 행렬은 직교 행렬이다.

## 부울 행렬 *Boolean Matrix*
부울 행렬은 모든 원소가 0과 1로 이루어진 행렬을 말한다.

부울 행렬의 연산과 부울 연산은 다르다. 부울 연산은 논리 연산이며 부울 행렬에서 사용하는 연산과는 다르다.

부울 행렬에서 사용하는 연산자는 접합, 교합, 부울곱의 세 가지 연산자가 있다.

### 접합 *Join*
A와 B의 접합은 다음과 같이 정의한다.

`A ∨ B = C`

(C<sub>ij</sub>)는 A<sub>ij</sub>=1 혹은 B<sub>ij</sub>=1 인 경우, 1이고 A<sub>ij</sub>와 B<sub>ij</sub>가 모두 0인 경우, 0이다.

### 교합 *Meet*
A와 B의 교합은 다음과 같이 정의한다.

`A ∧ B = C`

(C<sub>ij</sub>)는 A<sub>ij</sub>=1 이고 B<sub>ij</sub>=1 인 경우, 1이고 A<sub>ij</sub>와 B<sub>ij</sub> 중에 하나라도 0인 경우 0이다.

### 부울곱 *Boolean Product*
A와 B의 부울곱은 아래와 같이 정의한다.

`A ⊙ B = C`

행렬 A가 m x p의 부울 행렬이고, B가 p x n의 부울 행렬이면, A와 B의 부울곱은 m x n 부울 행렬이 되고, 다음과 같이 정의된다.

C<sub>ij</sub>에 대해, 어떤 k(1≤k≤p)에 대해, A<sub>ik</sub> = 1, B<sub>kj</sub> = 1 인 경우 1이고 이외에는 0이다.

## 행렬식 *Determinant*
A의 행렬식은 모든 정방 행렬 A에 대하여 고유한 수치 값을 대응시키는 것을 말하며, |A| 또는 det(A)로 표시한다.

2x2 행렬의 행렬식은 다음과 같이 정의한다.

```
det([[3, 2], [4, 6]] = 3*6 - 2*4 = 10
```

이 외에도 소행렬식*minor*과 여인수*cofactor* 개념이 있지만, 이들은 나중에 배워보자.

## 고유벡터와 고유값
어떤 벡터 V의 좌측에 행렬 A를 곱한 결과를 벡터 B로 나타낼 수 있다.

즉, 행렬 A를 이용하여 벡터 V를 벡터 B로 변환한 것이다. 이 과정을 선형 변환<sup>Linear Transformation</sup> 혹은 벡터 V를 벡터 B로 매핑<sup>mapping</sup>했다고 한다.

정방 행렬 A에 대해 AX = λX를 만족하는 X를 고유벡터<sup>eigen vector</sup>, 스칼라 λ를 고유값<sup>eigen value</sup>이라 한다.

행렬 A가 어떤 벡터 X에 선형 변환을 하는 선형 연산자일때, 해당 벡터 X에 대하여 λ만큼 확대하거나 축소한다는 의미이다.

n x n 행렬 A의 고유값(λ)을 구하기 위해 AX = λX를 AX = λIX로 수정하면 이는 `(λI-A)X=0`으로 쓸 수 있다.

λ가 고유값이 되기 위해서는 이 방정식에서 0이 아닌 해가 존재해야 한다. 0이 아닌 해를 갖기 위해서는 det(A-λI)=0이어야 한다. 이것을 A의 특성방정식<sup>characteristic equation</sup>이라 하고, 이 특정방정식을 만족하는 스칼라를 A의 고유값이라 한다.